general:
  name: "llama2-7b-v1"      
  model_name: "Llama2-7b"
  
# AWS and SageMaker settings
aws:
  # AWS region, this parameter is templatized, no need to change
  region: {region}
  # SageMaker execution role used to run FMBench, this parameter is templatized, no need to change
  sagemaker_execution_role: {role_arn}
  # S3 bucket to which metrics, plots and reports would be written to
  bucket: {write_bucket}

# directory paths in the write bucket, no need to change these
dir_paths:
  data_prefix: data
  prompts_prefix: prompts
  all_prompts_file: all_prompts.csv
  metrics_dir: metrics
  models_dir: models
  metadata_dir: metadata

# S3 information for reading datasets, scripts and tokenizer
s3_read_data:
  # read bucket name, templatized, if left unchanged will default to sagemaker-fmbench-read-<region>-<account_id>
  read_bucket: {read_bucket}

  # S3 prefix in the read bucket where deployment and inference scripts should be placed
  scripts_prefix: scripts
  
  # deployment and inference script files to be downloaded are placed in this list
  # only needed if you are creating a new deployment script or inference script
  # your HuggingFace token does need to be in this list and should be called "hf_token.txt"
  script_files:
  - hf_token.txt
  
  # This is the directory in S3 and locally where all the rules are stored. Each rule 
  # file represents a subjective criteria to be evaluated
  eval_prompts_dir: eval_criteria
  # the directory contains a folder that contains all the files with rules for evaluations
  # and another directory that stores the standard prompt template that is used for evlauation
  # of different answers at runtime
  eval_prompt_template_dir_list:
  - claude_eval_prompt_templates
  - llama3_eval_prompt_templates
  - cohere_eval_prompt_templates
  
  # These are the rules that are prefilled within the 
  # prompt templates evaluating for max voting or average
  # pooling
  eval_instructions_dir: eval_instructions
  eval_instructions_files:
  - evaluation_instructions_max_voting.txt
  - evaluation_instructions_avg_pooling.txt

  # configuration files (like this one) are placed in this prefix
  configs_prefix: configs

  # list of configuration files to download, for now only pricing.yml needs to be downloaded
  config_files:
  - pricing.yml

  # S3 prefix for the dataset files
  source_data_prefix: source_data
  # list of dataset files, the list below is from the LongBench dataset https://huggingface.co/datasets/THUDM/LongBench
  source_data_files:
  - 2wikimqa_e.jsonl
  - 2wikimqa.jsonl
  - hotpotqa_e.jsonl
  - hotpotqa.jsonl
  - narrativeqa.jsonl
  - triviaqa_e.jsonl
  - triviaqa.jsonl
  # S3 prefix for the tokenizer to be used with the models
  # NOTE 1: the same tokenizer is used with all the models being tested through a config file
  # NOTE 2: place your model specific tokenizers in a prefix named as <model_name>_tokenizer
  #         so the mistral tokenizer goes in mistral_tokenizer, Llama2 tokenizer goes in llama2_tokenizer and so on and so forth.
  tokenizer_prefix: llama2_tokenizer
  
  # S3 prefix for prompt templates
  prompt_template_dir: prompt_template

  # prompt template to use, NOTE: same prompt template gets used for all models being tested through a config file
  # the FMBench repo already contains a bunch of prompt templates so review those first before creating a new one
  prompt_template_file: prompt_template_llama2.txt

# steps to run, usually all of these would be
# set to yes so nothing needs to change here
# you could, however, bypass some steps for example
# set the 2_deploy_model.ipynb to no if you are re-running
# the same config file and the model is already deployed
run_steps:
  0_setup.ipynb: yes
  1_generate_data.ipynb: no
  2_deploy_model.ipynb: no
  3_run_inference.ipynb: no
  4_get_evaluations.ipynb: yes
  5_model_metric_analysis.ipynb: yes
  6_cleanup.ipynb: no

datasets:
  # Refer to the 1_generate_data.ipynb notebook
  # the dataset you use is expected to have the 
  # columns you put in prompt_template_keys list
  # and your prompt template also needs to have
  # the same placeholders (refer to the prompt template folder)
  prompt_template_keys:
  - input
  - context
  
  # maximum number of iterations per concurrency and payload size combination
  max_iters_per_combination: 105
  # minimum number of iterations per concurrency and payload size combination
  min_iters_per_combination: 5
  
  # if your dataset has multiple languages and it has a language
  # field then you could filter it for a language. Similarly,
  # you can filter your dataset to only keep prompts between
  # a certain token length limit (the token length is determined
  # using the tokenizer you provide in the tokenizer_prefix prefix in the
  # read S3 bucket). Each of the array entries below create a payload file
  # containing prompts matching the language and token length criteria.
  filters:
  - language: en    
    min_length_in_tokens: 1
    max_length_in_tokens: 500
    payload_file: payload_en_1-500.jsonl
  - language: en
    min_length_in_tokens: 500
    max_length_in_tokens: 1000
    payload_file: payload_en_500-1000.jsonl
  - language: en
    min_length_in_tokens: 1000
    max_length_in_tokens: 2000
    payload_file: payload_en_1000-2000.jsonl
  - language: en
    min_length_in_tokens: 2000
    max_length_in_tokens: 3000
    payload_file: payload_en_2000-3000.jsonl
  - language: en
    min_length_in_tokens: 3000
    max_length_in_tokens: 3840
    payload_file: payload_en_3000-3840.jsonl
    
# name of the file that contains the model evaluation information
# change to model_eval_avg pooling for average pooling use cases
model_evaluations: model_eval_all_info.yml

# We construct a PoLL from a panel of LLM judges being drawn from disparate model families. We consider two
# different voting functions for aggregating scores across the judges. For tasks where ground truth is provided, we use
# max voting, as all judgements are binary [correct, incorrect]. For Chatbot Arena we instead use average 
# pooling because judgements are scores ranging from 1-5 and a three judge panel often does not produce 
# a clear majority decision
PoLL_Composition_and_Voting: 
  # If you are looking to evaluate the model responses 
  # to corresponding sources of ground truth, then FMBench 
  # can use the max_voting method to get binary decisions and do a
  # majority vote from all panel judges on each model used in the inference
  # process. If you want your evaluations to be more tailored to specific criteria
  # and not a binary decision then use "avg_pooling" here
  method: max_voting # [avg_pooling, max_voting]
  # Enter the column name of your dataset that contains the ground truth if any. 
  # If there is no ground truth provided, leave this empty.
  ground_truth_col: answers # the ground truth column for the OpenOrca dataset is "response"
  # Set this variable to yes if you want to make partial correct/incorrect decisions based
  # on quantitative metrics like cosine similarity, levenshtein score and token set ratio. Set
  # this to yes only if you have a very direct QnA use case
  use_quantitative_metrics: no
  # these are the rules that are used to evaluate all of the candidate models.
  # these txt files are fit into the prompts for the Panel of LLM evaluators
  # while evaluating the candidate model responses.
  subjective_eval_criteria:
    accuracy: | 
        This criteria is for accuracy:
        1. Factual Correctness: The response should be factually accurate and free from errors or misinformation. It should align with information
        from the context fully.
        2. Relevance: The response should be directly relevant to the question or task at hand. It should address the question and context without 
        deviating or including irrelevant information.
        3. Completeness: The response should provide a comprehensive answer or solution to the question or task. It should not omit crucial details or 
        leave out important aspects of the required information.
        4. Consistency: The response should be consistent with the context and any provided background information. It should not contradict 
        previously established facts or make logically inconsistent statements.
        5. Specificity: The response should be specific and tailored to the particular question or task. It should avoid overly broad or generalized statements that lack the necessary level of detail.
        6. Objectivity: The response should be objective and impartial, free from biases or subjective opinions unless explicitly requested or appropriate for the task and the question.
        7. Clarity: The response should be clear, concise, and easy to understand. It should use appropriate language and avoid ambiguity or confusion.
        8. Timeliness: If applicable, the response should be up-to-date and reflect the most recent information or developments relevant to the question 
        or task.
        9. Domain Expertise: The response should demonstrate appropriate domain knowledge and expertise relevant to the subject matter of the question 
        or task.
    helpfulness: |
        This criteria is for helpfulness:
        1. Practical Value: The response should provide information or solutions that are actionable and useful to the user.
        2. Problem-Solving: The response should effectively address the user's problem or question, offering clear guidance or solutions.
        3. Clarity of Explanation: The information should be presented in a clear, easy-to-understand manner, avoiding unnecessary jargon.
        4. Thoroughness: The response should cover all aspects of the question or task comprehensively.
        5. Relevance to User Needs: The information provided should be tailored to the specific needs or context of the user's query.
    coherence: |
        This criteria is for coherence:
        1. Logical Flow: The response should have a clear and logical structure, with ideas flowing smoothly from one to the next.
        2. Consistency: All parts of the response should be consistent with each other, without contradictions or conflicting information.
        3. Contextual Relevance: The response should maintain relevance to the overall context of the conversation or task.
        4. Proper Transitions: There should be appropriate transitions between different parts or ideas within the response.
        5. Unified Theme: The entire response should revolve around a central theme or purpose, maintaining focus throughout.

# While the tests would run on all the datasets
# configured in the experiment entries below but 
# the price:performance analysis is only done for 1
# dataset which is listed below as the dataset_of_interest
metrics:
  dataset_of_interest: en_1000-2000

# all pricing information is in the pricing.yml file
# this file is provided in the repo. You can add entries
# to this file for new instance types and new Bedrock models
pricing: pricing.yml

# inference parameters, these are added to the payload
# for each inference request. The list here is not static
# any parameter supported by the inference container can be
# added to the list. Put the sagemaker parameters in the sagemaker
# section, bedrock parameters in the bedrock section (not shown here).
# Use the section name (sagemaker in this example) in the inference_spec.parameter_set
# section under experiments.
inference_parameters:
  sagemaker:
    do_sample: yes
    temperature: 0.1
    top_p: 0.92
    top_k: 120  
    max_new_tokens: 100
    return_full_text: False

# Configuration for experiments to be run. The experiments section is an array
# so more than one experiments can be added, these could belong to the same model
# but different instance types, or different models, or even different hosting
# options (such as one experiment is SageMaker and the other is Bedrock).
experiments:
  - name: llama2-7b-g5.xlarge-huggingface-pytorch-tgi-inference-2.0.1-tgi1.1.0
    # model_id is interpreted in conjunction with the deployment_script, so if you
    # use a JumpStart model id then set the deployment_script to jumpstart.py.
    # if deploying directly from HuggingFace this would be a HuggingFace model id
    # see the DJL serving deployment script in the code repo for reference.
    model_id: meta-textgeneration-llama-2-7b-f
    model_version: "3.*"
    model_name: llama2-7b-f
    ep_name: llama-2-7b-g5-xlarge
    instance_type: "ml.g5.xlarge"
    image_uri: '763104351884.dkr.ecr.{region}.amazonaws.com/huggingface-pytorch-tgi-inference:2.0.1-tgi1.1.0-gpu-py39-cu118-ubuntu20.04'
    deploy: yes
    instance_count: 1
    # FMBench comes packaged with multiple deployment scripts, such as scripts for JumpStart
    # scripts for deploying using DJL DeepSpeed, tensorRT etc. You can also add your own.
    # See repo for details    
    deployment_script: jumpstart.py
    # FMBench comes packaged with multiple inference scripts, such as scripts for SageMaker
    # and Bedrock. You can also add your own. See repo for details
    inference_script: sagemaker_predictor.py
    inference_spec:
      # this should match one of the sections in the inference_parameters section above
      parameter_set: sagemaker
      stream: False
      stop_token: ".</s>"
    # runs are done for each combination of payload file and concurrency level
    payload_files:
    - payload_en_1-500.jsonl
    - payload_en_500-1000.jsonl
    - payload_en_1000-2000.jsonl
    # - payload_en_2000-3000.jsonl
    # - payload_en_3000-3840.jsonl
    # concurrency level refers to number of requests sent in parallel to an endpoint
    # the next set of requests is sent once responses for all concurrent requests have
    # been received.
    concurrency_levels:
    - 1
    # - 2
    # - 4

    accept_eula: true
    # Environment variables to be passed to the container
    # this is not a fixed list, you can add more parameters as applicable.
    env:
      SAGEMAKER_PROGRAM: "inference.py"
      ENDPOINT_SERVER_TIMEOUT: "3600"
      MODEL_CACHE_ROOT: "/opt/ml/model"
      SAGEMAKER_ENV: "1"
      HF_MODEL_ID: "/opt/ml/model"
      MAX_INPUT_LENGTH: "4095"
      MAX_TOTAL_TOKENS: "4096"
      SM_NUM_GPUS: "1"
      SAGEMAKER_MODEL_SERVER_WORKERS: "1"

  - name: llama2-7b-g5.2xlarge-huggingface-pytorch-tgi-inference-2.0.1-tgi1.1.0
    # model_id is interpreted in conjunction with the deployment_script, so if you
    # use a JumpStart model id then set the deployment_script to jumpstart.py.
    # if deploying directly from HuggingFace this would be a HuggingFace model id
    # see the DJL serving deployment script in the code repo for reference. 
    model_id: meta-textgeneration-llama-2-7b-f
    model_version: "3.*"
    model_name: llama2-7b-f
    ep_name: llama-2-7b-g5-2xlarge
    instance_type: "ml.g5.2xlarge"
    image_uri: '763104351884.dkr.ecr.{region}.amazonaws.com/huggingface-pytorch-tgi-inference:2.0.1-tgi1.1.0-gpu-py39-cu118-ubuntu20.04'
    deploy: yes
    # FMBench comes packaged with multiple deployment scripts, such as scripts for JumpStart
    # scripts for deploying using DJL DeepSpeed, tensorRT etc. You can also add your own.
    # See repo for details
    instance_count: 1
    deployment_script: jumpstart.py
    # FMBench comes packaged with multiple inference scripts, such as scripts for SageMaker
    # and Bedrock. You can also add your own. See repo for details
    inference_script: sagemaker_predictor.py
    inference_spec:
      # this should match one of the sections in the inference_parameters section above
      parameter_set: sagemaker
      stream: False
      stop_token: "."
    # runs are done for each combination of payload file and concurrency level
    payload_files:
    - payload_en_1-500.jsonl
    - payload_en_500-1000.jsonl
    - payload_en_1000-2000.jsonl
    # - payload_en_2000-3000.jsonl
    # - payload_en_3000-3840.jsonl
    
    # concurrency level refers to number of requests sent in parallel to an endpoint
    # the next set of requests is sent once responses for all concurrent requests have
    # been received.
    concurrency_levels:
    - 1
    # - 2
    # - 4

    # Added for models that require accepting a EULA
    accept_eula: true
    # Environment variables to be passed to the container
    # this is not a fixed list, you can add more parameters as applicable.
    env:
      SAGEMAKER_PROGRAM: "inference.py"
      ENDPOINT_SERVER_TIMEOUT: "3600"
      MODEL_CACHE_ROOT: "/opt/ml/model"
      SAGEMAKER_ENV: "1"
      HF_MODEL_ID: "/opt/ml/model"
      MAX_INPUT_LENGTH: "4095"
      MAX_TOTAL_TOKENS: "4096"
      SM_NUM_GPUS: "1"
      SAGEMAKER_MODEL_SERVER_WORKERS: "1"

# parameters related to how the final report is generated
report:
  # markdown report title
  title: "Performance benchmarking results for Llama2-7b on `g5.xlarge` and `g5.2xlarge` using the HuggingFace TGI container"
  # constraints for latency, cost and error rate
  # an experiment is considered successful or eligible for
  # selection for a use-case if it satisfies all of the following
  # constraints. Experiments are scored as per this criteria
  # higher score is better (see 4_model_metric_analysis.ipynb score_run function)
  latency_budget: 2
  cost_per_10k_txn_budget: 20
  error_rate_budget: 0
  # other misc reporting parameters, see 4_model_metric_analysis.ipynb
  # for more information
  per_inference_request_file: per_inference_request_results.csv
  all_metrics_file: all_metrics.csv
  txn_count_for_showing_cost: 10000
  v_shift_w_single_instance: 0.025
  v_shift_w_gt_one_instance: 0.025

