general:
  name: "fmbench-bedrock"      
  model_name: "FMs available in Amazon Bedrock"
  
# AWS and SageMaker settings
aws:
  region: {region}
  # uncomment and set the Role ARN if not running on sagemaker
  sagemaker_execution_role: {role_arn}
  ## these are the buckets/resources you will create in your account below:
  bucket: {write_bucket}
  

## WRITE BUCKET -- Write the results, data, metrics, endpoint.json and payloads to this bucket directory
dir_paths:
    data_prefix: data ## add the prefix for all your data management/storage
    prompts_prefix: prompts
    all_prompts_file: all_prompts.csv
    metrics_dir: metrics
    models_dir: models
    metadata_dir: metadata ## add a file here to dynamically track the metrics dir

## READ BUCKET -- Represents the section to read from scripts, source data and tokenizer for a separate s3 bucket for read/write segregation
s3_read_data:
    read_bucket: {read_bucket}
    scripts_prefix: scripts ## add your own scripts in case you are using anything that is not on jumpstart
    script_files:
    - hf_token.txt  ## add your scripts files you have in s3 (including inference files, serving stacks, if any)
    configs_prefix: configs
    config_files:
    - pricing.yml ## mention the name of the config files that you want to be downloaded from s3 into the configs directory locally
    source_data_prefix: source_data  ## Add a source_data folder to store your raw data in an s3 path configured by you
    source_data_files:
    - 2wikimqa_e.jsonl
    - 2wikimqa.jsonl
    - hotpotqa_e.jsonl
    - hotpotqa.jsonl
    - narrativeqa.jsonl
    - triviaqa_e.jsonl
    - triviaqa.jsonl
    tokenizer_prefix: tokenizer ## add the tokenizer.json and config.json from your specific tokenizer type
    prompt_template_dir: prompt_template
    prompt_template_file: prompt_template_titan_text.txt ## add your desired prompt template type

## section that enables container to run notebooks and python scripts automatically 
run_steps:
    0_setup.ipynb: yes
    1_generate_data.ipynb: yes
    2_deploy_model.ipynb: no
    3_run_inference.ipynb: yes
    4_model_metric_analysis.ipynb: yes
    5_cleanup.ipynb: no

datasets:
  prompt_template_keys:
  - input
  - context
  # - text
  filters:
  - language: en    
    min_length_in_tokens: 1
    max_length_in_tokens: 500
    payload_file: payload_en_1-500.jsonl
  - language: en
    min_length_in_tokens: 500
    max_length_in_tokens: 1000
    payload_file: payload_en_500-1000.jsonl
  - language: en
    min_length_in_tokens: 1000
    max_length_in_tokens: 2000
    payload_file: payload_en_1000-2000.jsonl
  - language: en
    min_length_in_tokens: 2000
    max_length_in_tokens: 3000
    payload_file: payload_en_2000-3000.jsonl
  - language: en
    min_length_in_tokens: 3000
    max_length_in_tokens: 3840
    payload_file: payload_en_3000-3840.jsonl
 
metrics:
  dataset_of_interest: en_3000-3840

# name of the file that contains the model evaluation information
# change to model_eval_avg pooling for average pooling use cases
model_evaluations: model_eval_all_info.yml

# We construct a PoLL from a panel of LLM judges being drawn from disparate model families. We consider two
# different voting functions for aggregating scores across the judges. For tasks where ground truth is provided, we use
# max voting, as all judgements are binary [correct, incorrect]. For Chatbot Arena we instead use average 
# pooling because judgements are scores ranging from 1-5 and a three judge panel often does not produce 
# a clear majority decision
PoLL_Composition_and_Voting: 
  # If you are looking to evaluate the model responses 
  # to corresponding sources of ground truth, then FMBench 
  # can use the max_voting method to get binary decisions and do a
  # majority vote from all panel judges on each model used in the inference
  # process. If you want your evaluations to be more tailored to specific criteria
  # and not a binary decision then use "avg_pooling" here
  method: max_voting # avg_pooling
  # Enter the column name of your dataset that contains the ground truth if any. 
  # If there is no ground truth provided, leave this empty.
  ground_truth_col: answers
  # Set this variable to yes if you want to make partial correct/incorrect decisions based
  # on quantitative metrics like cosine similarity, levenshtein score and token set ratio. Set
  # this to yes only if you have a very direct QnA use case
  use_quantitative_metrics: no
  # these are the rules that are used to evaluate all of the candidate models.
  # these txt files are fit into the prompts for the Panel of LLM evaluators
  # while evaluating the candidate model responses.
  subjective_eval_criteria:
    accuracy: | 
        This criteria is for accuracy:
        1. Factual Correctness: The response should be factually accurate and free from errors or misinformation. It should align with information
        from the context fully.
        2. Relevance: The response should be directly relevant to the question or task at hand. It should address the question and context without 
        deviating or including irrelevant information.
        3. Completeness: The response should provide a comprehensive answer or solution to the question or task. It should not omit crucial details or 
        leave out important aspects of the required information.
        4. Consistency: The response should be consistent with the context and any provided background information. It should not contradict 
        previously established facts or make logically inconsistent statements.
        5. Specificity: The response should be specific and tailored to the particular question or task. It should avoid overly broad or generalized statements that lack the necessary level of detail.
        6. Objectivity: The response should be objective and impartial, free from biases or subjective opinions unless explicitly requested or appropriate for the task and the question.
        7. Clarity: The response should be clear, concise, and easy to understand. It should use appropriate language and avoid ambiguity or confusion.
        8. Timeliness: If applicable, the response should be up-to-date and reflect the most recent information or developments relevant to the question 
        or task.
        9. Domain Expertise: The response should demonstrate appropriate domain knowledge and expertise relevant to the subject matter of the question 
        or task.
    helpfulness: |
        This criteria is for helpfulness:
        1. Practical Value: The response should provide information or solutions that are actionable and useful to the user.
        2. Problem-Solving: The response should effectively address the user's problem or question, offering clear guidance or solutions.
        3. Clarity of Explanation: The information should be presented in a clear, easy-to-understand manner, avoiding unnecessary jargon.
        4. Thoroughness: The response should cover all aspects of the question or task comprehensively.
        5. Relevance to User Needs: The information provided should be tailored to the specific needs or context of the user's query.
    coherence: |
        This criteria is for coherence:
        1. Logical Flow: The response should have a clear and logical structure, with ideas flowing smoothly from one to the next.
        2. Consistency: All parts of the response should be consistent with each other, without contradictions or conflicting information.
        3. Contextual Relevance: The response should maintain relevance to the overall context of the conversation or task.
        4. Proper Transitions: There should be appropriate transitions between different parts or ideas within the response.
        5. Unified Theme: The entire response should revolve around a central theme or purpose, maintaining focus throughout.
 
pricing: pricing.yml ## mention the name of the file that contains pricing information, within s3 or locally in the configs folder
  
inference_parameters: 
  bedrock:
    temperature: 0.1
    max_tokens: 100
    top_p: 0.92
    caching: False

# Model configurations for mistral 7b instruct on Amazon Bedrock
experiments:
  - name: amazon.titan-text-express-v1
    model_id: amazon.titan-text-express-v1
    model_version: "*"
    model_name: amazon.titan-text-express-v1
    ep_name: amazon.titan-text-express-v1
    instance_type: amazon.titan-text-express-v1
    image_uri:
    deploy: no
    instance_count:
    deployment_script:
    inference_script: bedrock_predictor.py
    inference_spec:
      split_input_and_parameters: no
      parameter_set: bedrock
    payload_files:
    - payload_en_1-500.jsonl
    - payload_en_500-1000.jsonl
    - payload_en_1000-2000.jsonl
    - payload_en_2000-3000.jsonl
    - payload_en_3000-3840.jsonl
    concurrency_levels:
    - 1
    - 2
    - 4
    - 6
    - 8
    - 10
    env: 
    
report:
  latency_budget: 2
  cost_per_10k_txn_budget: 50
  error_rate_budget: 0
  per_inference_request_file: per_inference_request_results.csv
  all_metrics_file: all_metrics.csv
  txn_count_for_showing_cost: 10000
  v_shift_w_single_instance: 0.025
  v_shift_w_gt_one_instance: 0.025